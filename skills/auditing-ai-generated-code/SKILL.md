---
name: auditing-ai-generated-code
description: Use when code was generated by AI tools, evolved without a deliberate architecture, works but feels fragile, or needs to transition from prototype to production. Triggers include "review my code", "is this production-ready", "audit this codebase", "check for technical debt", or any request to assess code quality before shipping.
---

# Auditing AI-Generated Code

## Overview

AI-generated code fails differently than human-written code. It looks correct, passes surface tests, and still ships silent data loss, hallucinated dependencies, and hardcoded secrets. This skill produces a traceable production-readiness report.

**Core principle:** Every finding must be locatable in the code provided. Report only real issues—no invented problems, unnecessary rewrites, or inflated scores.

**REQUIRED BACKGROUND:** You MUST understand superpowers:test-driven-development before using this skill. Apply the same evidence-based discipline to audit findings.

## When to Use

- Code came from a vibe coding session, Cursor, Claude Code, Google AI Studio, or similar
- You see `except Exception: pass`, `try/catch` blocks that swallow errors silently
- Imports reference libraries or APIs not in the declared dependencies
- Business logic is buried inside route handlers or UI components
- Credentials, tokens, or API keys appear as string literals or injected via framework conventions (e.g., Vite `VITE_` env vars exposed to client bundles)
- `localStorage` used as persistence layer for mission-critical data
- Code worked in a demo but hasn't been tested under real conditions

## When NOT to Use

- Code you wrote yourself with tests already passing (use `systematic-debugging`)
- You want refactoring suggestions only (this skill audits, it does not redesign)
- After fixing findings, to confirm they are resolved (use `verification-before-completion`)

## Pre-Audit Checklist

Before analyzing anything, confirm:

1. What is the code supposed to do? (one sentence from the user)
2. What language/runtime/framework?
3. Is there a dependency manifest (requirements.txt, package.json, etc.)?

If any item is missing, state what is absent and proceed with available information — **do not halt**.

## Audit Dimensions

Evaluate across all seven dimensions. For each finding record: dimension, title, exact location (file + line if available), severity, explanation, and concrete fix.

**Do not invent findings. Do not report issues you cannot substantiate from the code provided.**

| # | Dimension | Key Patterns |
|---|-----------|-------------|
| 1 | **Architecture & Design** | Business logic in handlers/UI, god objects, tight coupling, blurred system boundaries |
| 2 | **Consistency & Maintainability** | Naming inconsistencies, mixed paradigms, copy-paste logic, obscuring abstractions |
| 3 | **Robustness & Error Handling** | Missing input validation, silent `except`/`catch`, unhandled edge cases, no fallback logic |
| 4 | **Production Risks** | Hardcoded config/URLs/timeouts, missing logging, N+1 queries, blocking I/O in async contexts |
| 5 | **Security & Safety** | Unsanitized input, secrets in source or logs, insecure defaults, trust boundary violations |
| 6 | **Dead or Hallucinated Code** | Defined but never called, non-existent imports, wrong API versions, contradicting annotations |
| 7 | **Technical Debt Hotspots** | Deep nesting (3-4+ levels), boolean flags changing behavior, 5+ param functions, high change blast radius |

## Output Format

Produce the audit report in exactly this structure. If a section has no findings, write "None identified."

```text
Input: [file name(s) or "code snippet"]
Assumptions: [list any assumptions made]

### Critical Issues (Must Fix Before Production)
[CRITICAL] Short descriptive title
Location: filename.tsx, line 42
Dimension: Security / Robustness / etc.
Problem: What is wrong and why it is dangerous.
Fix: Minimum change required.

### High-Risk Issues
[HIGH] ...

### Maintainability Problems
[MEDIUM] or [LOW] ...

### Production Readiness Score
Score: XX / 100
[2-3 sentences citing specific findings that drove the score]

### Refactoring Priorities
1. [Priority] Fix title — addresses [CRITICAL/HIGH ref] — effort: S/M/L
2. ...
```

**Score rubric:**

| Range | Meaning |
|-------|--------|
| 0-30 | Not deployable. Critical failures likely under normal use. |
| 31-50 | High risk. Significant rework before any production exposure. |
| 51-70 | Low-stakes or internal use only, with close monitoring. |
| 71-85 | Production-viable with targeted fixes. Risks are bounded. |
| 86-100 | Production-ready. Minor improvements only. |

Deductions: Critical finding = -30 to -40 pts. High finding = -5 to -10 pts. 3+ Medium in one dimension = -5 pts.

**Effort scale:** S = < 1 day, M = 1-3 days, L = > 3 days.

## Behavioral Rules (Non-Negotiable)

**NEVER:**
- Invent findings not present in the provided code
- Rewrite code that isn't broken — flag it, don't replace it
- Give a score above 70/100 to code with any CRITICAL finding
- Produce thematic groupings without severity separation
- Skip the "Dead or Hallucinated Code" dimension — this is the most common AI failure mode
- Describe dead validation logic as a "product design flaw" — classify it as dead code

**ALWAYS:**
- Quote the exact code evidence for every finding
- Distinguish "not found in provided code" from "this pattern is absent"
- State explicitly if you cannot verify a dependency (ask for manifest)
- Give the score before the justification, not after
- Include Refactoring Priorities with effort estimates in every report

## Red Flags — Stop and Clarify

If you encounter these, **stop and ask before scoring:**

- No dependency manifest provided (hallucinated imports cannot be verified)
- Code references external services with no credentials shown (may be env vars)
- Test files exist but are empty or contain only placeholders

## Common AI-Generated Failure Patterns

These are the patterns that generic code review misses and this skill explicitly targets:

```tsx
// [HIGH] Dead or Hallucinated Code — validation logic that never runs
// handleRegister defines email/password checks but the critical path
// bypasses them entirely — looks like validation, provides none
const handleRegister = async () => {
  if (!email || !password) return; // never reached in normal flow
  await registerUser(email, password);
};

// [CRITICAL] Security — API key injected into client bundle via Vite convention
// VITE_ prefix exposes this to all users via window.__VITE_ENV__
const apiKey = import.meta.env.VITE_GEMINI_API_KEY;

// [HIGH] Production Risk — localStorage as persistence for mission-critical data
// Cleared by browsers, inaccessible in private mode, no backup
localStorage.setItem('timeEntries', JSON.stringify(entries));

// [MEDIUM] Architecture — monolithic component (450+ lines, 3+ responsibilities)
// AdminView.tsx handles data fetching, business rules, and rendering
// impossible to test or extend independently
```

## Common Rationalizations to Reject

| Rationalization | Reality |
|---|---|
| "The dead validation is a product decision" | Dead code is dead code. Flag it, let the developer decide. |
| "The score is low but I'll soften it" | An inflated score is a false negative. Don't do it. |
| "I'll group by theme instead of severity" | Severity separation is mandatory. Themes hide priority. |
| "The hallucinated import might exist" | Cannot verify without manifest. Flag it explicitly. |
| "Skip Dead Code section, nothing obvious" | Always evaluate the dimension. Absence is a valid finding. |

## Related Skills

- **systematic-debugging**: Use after fixing findings to trace remaining failures
- **verification-before-completion**: Use after fixes to confirm findings are resolved
- **test-driven-development**: Use to add test coverage after audit is clean
- **requesting-code-review**: Use for human peer review after automated audit
